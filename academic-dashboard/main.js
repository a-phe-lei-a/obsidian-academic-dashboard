/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  VIEW_TYPE_ACADEMIC_DASHBOARD: () => VIEW_TYPE_ACADEMIC_DASHBOARD,
  default: () => AcademicDashboardPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");

// src/lang.ts
var translations = {
  fr: {
    // Settings
    settingsTitle: "Param\xE8tres du tableau de bord acad\xE9mique",
    sectionGeneral: "G\xE9n\xE9ral",
    sectionGeneralDesc: "Configuration de base pour l'affichage et le filtrage.",
    dashboardTitle: "Titre du tableau de bord",
    dashboardTitleDesc: "Titre affich\xE9 dans l'onglet du tableau de bord.",
    targetYear: "Ann\xE9e acad\xE9mique cible",
    targetYearDesc: "L'ann\xE9e acad\xE9mique \xE0 filtrer (ex: '2025-2026').",
    sectionSchedule: "Calendrier semestriel",
    scheduleDesc: "D\xE9finissez les dates pour suivre la progression et g\xE9rer l'affichage.",
    semester1: "Semestre 1",
    semester2: "Semestre 2",
    startDate: "Date de d\xE9but",
    endDate: "Date de fin",
    sectionVisuals: "Fonctionnalit\xE9s & visuels",
    sectionVisualsDesc: "Personnalisez l'apparence et les outils de productivit\xE9.",
    pomodoroTimer: "Minuteur Pomodoro",
    pomodoroDesc: "Dur\xE9e d'une session en minutes pour les estimations.",
    evalColors: "Couleurs d'\xE9valuation",
    evalColorsDesc: "Associez des types d'\xE9valuation \xE0 des couleurs sp\xE9cifiques.",
    addColor: "Ajouter une couleur",
    sectionAdvanced: "Configuration des propri\xE9t\xE9s",
    advancedDesc: "D\xE9finissez les cl\xE9s de propri\xE9t\xE9s Frontmatter exactes utilis\xE9es dans vos notes.",
    propYear: "Propri\xE9t\xE9 ann\xE9e acad\xE9mique",
    propYearDesc: "Cl\xE9 pour l'ann\xE9e (ex: ied_ec_academic_year).",
    propSemester: "Propri\xE9t\xE9 semestre",
    propSemesterDesc: "Cl\xE9 pour le semestre (ex: ied_ec_semestre).",
    propUE: "Propri\xE9t\xE9 UE",
    propUEDesc: "Cl\xE9 pour l'unit\xE9 d'enseignement (ex: ied_ue).",
    propVolume: "Propri\xE9t\xE9 volume horaire",
    propVolumeDesc: "Cl\xE9 pour le volume horaire (ex: ied_ec_volume).",
    propEvalType: "Propri\xE9t\xE9 type d'\xE9valuation",
    propEvalTypeDesc: "Cl\xE9 pour le type d'\xE9valuation (ex: ied_ec_evaluation_type).",
    propExamDates: "Propri\xE9t\xE9s dates d'examen",
    propExamDatesDesc: "Cl\xE9s pour les dates de session 1 et 2.",
    propSupervision: "Propri\xE9t\xE9s supervision",
    propSupervisionDesc: "Cl\xE9s pour le d\xE9but et la fin de supervision.",
    propExcluded: "Dossiers exclus",
    propExcludedDesc: "Un chemin de dossier par ligne \xE0 ignorer.",
    // View
    viewSemester1: "Semestre 1",
    viewSemester2: "Semestre 2",
    viewOthers: "Autres / Ind\xE9fini",
    viewNoCourses: "Aucun cours trouv\xE9 pour ce semestre.",
    viewNoPages: "Aucune page trouv\xE9e pour cette ann\xE9e acad\xE9mique.",
    viewEnds: "Fin le",
    viewAllTasksDone: "Toutes les t\xE2ches sont termin\xE9es",
    // Progress Bar
    progStartIn: "Commence dans",
    progStartInMini: "Dans ",
    progDays: "j",
    progDone: "Termin\xE9",
    progWeeksLeft: "semaine(s) restante(s)",
    progWeeks: "sem",
    // mini
    // General
    settingLanguage: "Langue",
    settingLanguageDesc: "Choisissez la langue de l'interface."
  },
  en: {
    // Settings
    settingsTitle: "Academic Dashboard Settings",
    sectionGeneral: "General",
    sectionGeneralDesc: "Basic configuration for display and filtering.",
    dashboardTitle: "Dashboard Title",
    dashboardTitleDesc: "Title to display in the dashboard tab.",
    targetYear: "Target Academic Year",
    targetYearDesc: "The academic year to filter for (e.g. '2025-2026').",
    sectionSchedule: "Semester Schedule",
    scheduleDesc: "Set dates to track progress bars and manage display.",
    semester1: "Semester 1",
    semester2: "Semester 2",
    startDate: "Start Date",
    endDate: "End Date",
    sectionVisuals: "Features & Visuals",
    sectionVisualsDesc: "Customize appearance and productivity tools.",
    pomodoroTimer: "Pomodoro Timer",
    pomodoroDesc: "Duration of one session in minutes for estimates.",
    evalColors: "Evaluation Colors",
    evalColorsDesc: "Map specific evaluation types to colors.",
    addColor: "Add Color Mapping",
    sectionAdvanced: "Property Configuration",
    advancedDesc: "Define the specific Frontmatter property keys used in your notes.",
    propYear: "Academic Year Property",
    propYearDesc: "Key for the year (e.g. ied_ec_academic_year).",
    propSemester: "Semester Property",
    propSemesterDesc: "Key for the semester (e.g. ied_ec_semestre).",
    propUE: "UE Property",
    propUEDesc: "Key for the teaching unit (e.g. ied_ue).",
    propVolume: "Volume Property",
    propVolumeDesc: "Key for the course volume (e.g. ied_ec_volume).",
    propEvalType: "Evaluation Type Property",
    propEvalTypeDesc: "Key for evaluation type (e.g. ied_ec_evaluation_type).",
    propExamDates: "Exam Dates Properties",
    propExamDatesDesc: "Keys for session 1 and 2 dates.",
    propSupervision: "Supervision Properties",
    propSupervisionDesc: "Keys for supervision start and end dates.",
    propExcluded: "Excluded Folders",
    propExcludedDesc: "One folder path per line to ignore.",
    // View
    viewSemester1: "Semester 1",
    viewSemester2: "Semester 2",
    viewOthers: "Others / Undefined",
    viewNoCourses: "No courses found for this semester.",
    viewNoPages: "No pages found for this academic year.",
    viewEnds: "Ends",
    viewAllTasksDone: "All tasks are completed",
    // Progress Bar
    progStartIn: "Start in",
    progStartInMini: "In ",
    progDays: "d",
    progDone: "Done",
    progWeeksLeft: "week(s) left",
    progWeeks: "w",
    // mini
    // General
    settingLanguage: "Language",
    settingLanguageDesc: "Choose the interface language."
  }
};
function t(lang, key) {
  const l = lang === "en" || lang === "fr" ? lang : "fr";
  return translations[l][key] || translations["fr"][key];
}

// src/settings.ts
var DEFAULT_SETTINGS = {
  language: "fr",
  academicYear: "2025-2026",
  propertyName: "ied_ec_academic_year",
  semesterPropertyName: "ied_ec_semestre",
  uePropertyName: "ied_ue",
  excludedFolders: "templates",
  s1StartDate: "2025-09-22",
  s1EndDate: "2025-12-19",
  s2StartDate: "2026-01-19",
  s2EndDate: "2026-04-11",
  volumePropertyName: "ied_ec_volume",
  pomodoroMinutes: 40,
  evaluationTypePropertyName: "ied_ec_evaluation_type",
  dashboardTitle: "IED Dashboard",
  evaluationColors: "Examen sur table: #ff5555\nDossier Moodle: #55aaff",
  session1PropertyName: "ied_ec_session_1",
  session2PropertyName: "ied_ec_session_2",
  supervisionStartPropertyName: "ied_ec_supervision_start",
  supervisionEndPropertyName: "ied_ec_supervision_end"
};
var AcademicDashboardSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    const l = this.plugin.settings.language;
    containerEl.empty();
    containerEl.addClass("academic-settings-flat");
    containerEl.createEl("h2", { text: "Academic Dashboard", cls: "academic-main-title" });
    this.addHeader(containerEl, t(l, "sectionGeneral"));
    new import_obsidian.Setting(containerEl).setName(t(l, "settingLanguage")).setDesc(t(l, "settingLanguageDesc")).addDropdown((d) => d.addOption("fr", "Fran\xE7ais").addOption("en", "English").setValue(this.plugin.settings.language).onChange(async (v) => {
      this.plugin.settings.language = v;
      await this.plugin.saveSettings();
      this.display();
    }));
    new import_obsidian.Setting(containerEl).setName(t(l, "dashboardTitle")).setDesc(t(l, "dashboardTitleDesc")).addText((t2) => t2.setPlaceholder("My Dashboard").setValue(this.plugin.settings.dashboardTitle).onChange(async (v) => {
      this.plugin.settings.dashboardTitle = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName(t(l, "targetYear")).setDesc(t(l, "targetYearDesc")).addText((t2) => t2.setPlaceholder("2025-2026").setValue(this.plugin.settings.academicYear).onChange(async (v) => {
      this.plugin.settings.academicYear = v;
      await this.plugin.saveSettings();
    }));
    this.addHeader(containerEl, t(l, "sectionSchedule"));
    new import_obsidian.Setting(containerEl).setName(t(l, "semester1")).setDesc("Start Date \u2014 End Date").addText((text) => {
      text.inputEl.type = "date";
      text.setValue(this.plugin.settings.s1StartDate || "").onChange(async (v) => {
        this.plugin.settings.s1StartDate = v;
        await this.plugin.saveSettings();
      });
    }).addText((text) => {
      text.inputEl.type = "date";
      text.setValue(this.plugin.settings.s1EndDate || "").onChange(async (v) => {
        this.plugin.settings.s1EndDate = v;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName(t(l, "semester2")).setDesc("Start Date \u2014 End Date").addText((text) => {
      text.inputEl.type = "date";
      text.setValue(this.plugin.settings.s2StartDate || "").onChange(async (v) => {
        this.plugin.settings.s2StartDate = v;
        await this.plugin.saveSettings();
      });
    }).addText((text) => {
      text.inputEl.type = "date";
      text.setValue(this.plugin.settings.s2EndDate || "").onChange(async (v) => {
        this.plugin.settings.s2EndDate = v;
        await this.plugin.saveSettings();
      });
    });
    this.addHeader(containerEl, t(l, "sectionVisuals"));
    new import_obsidian.Setting(containerEl).setName(t(l, "pomodoroTimer")).setDesc(t(l, "pomodoroDesc")).addText((t2) => {
      t2.inputEl.type = "number";
      t2.setValue(String(this.plugin.settings.pomodoroMinutes)).onChange(async (v) => {
        const val = parseInt(v);
        if (!isNaN(val) && val > 0) {
          this.plugin.settings.pomodoroMinutes = val;
          await this.plugin.saveSettings();
        }
      });
    });
    containerEl.createDiv({ text: t(l, "evalColors"), cls: "academic-sub-label" });
    const colorContainer = containerEl.createDiv({ cls: "academic-color-container" });
    this.renderColorEditor(colorContainer, l);
    this.addHeader(containerEl, t(l, "sectionAdvanced"));
    const details = containerEl.createEl("details");
    details.createEl("summary", { text: "Show Property Names" });
    const advContent = details.createDiv({ cls: "academic-advanced-inner" });
    const addProp = (n, v, s) => {
      new import_obsidian.Setting(advContent).setName(n).addText((t2) => t2.setValue(v).onChange(async (val) => await s(val)));
    };
    addProp(t(l, "propYear"), this.plugin.settings.propertyName, async (v) => {
      this.plugin.settings.propertyName = v;
      await this.plugin.saveSettings();
    });
    addProp(t(l, "propSemester"), this.plugin.settings.semesterPropertyName, async (v) => {
      this.plugin.settings.semesterPropertyName = v;
      await this.plugin.saveSettings();
    });
    addProp(t(l, "propUE"), this.plugin.settings.uePropertyName, async (v) => {
      this.plugin.settings.uePropertyName = v;
      await this.plugin.saveSettings();
    });
    addProp(t(l, "propVolume"), this.plugin.settings.volumePropertyName, async (v) => {
      this.plugin.settings.volumePropertyName = v;
      await this.plugin.saveSettings();
    });
    addProp(t(l, "propEvalType"), this.plugin.settings.evaluationTypePropertyName, async (v) => {
      this.plugin.settings.evaluationTypePropertyName = v;
      await this.plugin.saveSettings();
    });
    addProp(`${t(l, "propExamDates")} (S1)`, this.plugin.settings.session1PropertyName, async (v) => {
      this.plugin.settings.session1PropertyName = v;
      await this.plugin.saveSettings();
    });
    addProp(`${t(l, "propExamDates")} (S2)`, this.plugin.settings.session2PropertyName, async (v) => {
      this.plugin.settings.session2PropertyName = v;
      await this.plugin.saveSettings();
    });
    addProp(`${t(l, "propSupervision")} (Start)`, this.plugin.settings.supervisionStartPropertyName, async (v) => {
      this.plugin.settings.supervisionStartPropertyName = v;
      await this.plugin.saveSettings();
    });
    addProp(`${t(l, "propSupervision")} (End)`, this.plugin.settings.supervisionEndPropertyName, async (v) => {
      this.plugin.settings.supervisionEndPropertyName = v;
      await this.plugin.saveSettings();
    });
    new import_obsidian.Setting(advContent).setName(t(l, "propExcluded")).addTextArea((t2) => t2.setValue(this.plugin.settings.excludedFolders).onChange(async (v) => {
      this.plugin.settings.excludedFolders = v;
      await this.plugin.saveSettings();
    }));
  }
  addHeader(container, text) {
    container.createEl("h3", { text, cls: "academic-section-header" });
  }
  createDateSetting(container, name, value, cb) {
    const div = container.createDiv({ cls: "academic-inline-date" });
    div.createSpan({ text: name });
    const input = div.createEl("input", { type: "date", value });
    input.onchange = async () => await cb(input.value);
  }
  renderColorEditor(container, l) {
    container.empty();
    let mappings = [];
    if (this.plugin.settings.evaluationColors) {
      mappings = this.plugin.settings.evaluationColors.split("\n").map((line) => {
        const [type, ...rest] = line.split(":");
        return type && rest.length ? { type: type.trim(), color: rest.join(":").trim() } : null;
      }).filter((x) => x !== null);
    }
    if (mappings.length === 0) {
      const empty = container.createDiv({ cls: "academic-empty-state" });
      empty.setText("No custom colors defined.");
    }
    mappings.forEach((m, idx) => {
      const row = container.createDiv({ cls: "academic-color-item" });
      const picker = row.createEl("input", { type: "color", value: m.color, cls: "academic-color-input" });
      const hexInput = row.createEl("input", { type: "text", value: m.color, cls: "academic-color-hex" });
      hexInput.placeholder = "#000000";
      const nameInput = row.createEl("input", { type: "text", value: m.type, cls: "academic-color-text" });
      nameInput.placeholder = "Evaluation Type";
      picker.oninput = () => {
        hexInput.value = picker.value;
      };
      picker.onchange = async () => {
        mappings[idx].color = picker.value;
        await this.saveColors(mappings);
      };
      hexInput.onchange = async () => {
        let val = hexInput.value;
        if (!val.startsWith("#"))
          val = "#" + val;
        if (/^#[0-9A-F]{6}$/i.test(val)) {
          picker.value = val;
          mappings[idx].color = val;
          await this.saveColors(mappings);
        } else {
          hexInput.value = mappings[idx].color;
        }
      };
      nameInput.onchange = async () => {
        mappings[idx].type = nameInput.value;
        await this.saveColors(mappings);
      };
      const delBtn = row.createEl("button", { cls: "academic-btn-icon" });
      delBtn.setText("\u2715");
      delBtn.setAttribute("aria-label", "Remove");
      delBtn.onclick = async () => {
        mappings.splice(idx, 1);
        await this.saveColors(mappings);
        this.renderColorEditor(container, l);
      };
    });
    const btnContainer = container.createDiv({ cls: "academic-btn-row" });
    const addBtn = btnContainer.createEl("button", { text: t(l, "addColor"), cls: "mod-cta" });
    addBtn.onclick = async () => {
      mappings.push({ type: "New Type", color: "#55aaff" });
      await this.saveColors(mappings);
      this.renderColorEditor(container, l);
    };
  }
  async saveColors(mappings) {
    this.plugin.settings.evaluationColors = mappings.map((m) => `${m.type}: ${m.color}`).join("\n");
    await this.plugin.saveSettings();
  }
};

// src/view.ts
var import_obsidian2 = require("obsidian");
var AcademicDashboardView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.cache = /* @__PURE__ */ new Map();
    this.isRefreshing = false;
    this.plugin = plugin;
    this.debouncedRefresh = (0, import_obsidian2.debounce)(this.safeRefresh.bind(this), 1e3, true);
  }
  getViewType() {
    return VIEW_TYPE_ACADEMIC_DASHBOARD;
  }
  getDisplayText() {
    return this.plugin.settings.dashboardTitle || "Academic Dashboard";
  }
  getIcon() {
    return "graduation-cap";
  }
  async onOpen() {
    this.registerEvent(this.app.metadataCache.on("changed", () => this.debouncedRefresh()));
    this.registerEvent(this.app.vault.on("create", () => this.debouncedRefresh()));
    this.registerEvent(this.app.vault.on("delete", () => this.debouncedRefresh()));
    this.registerEvent(this.app.vault.on("rename", () => this.debouncedRefresh()));
    await this.safeRefresh();
  }
  async safeRefresh() {
    if (this.isRefreshing)
      return;
    this.isRefreshing = true;
    try {
      await this.refresh();
    } catch (e) {
      console.error("Academic Dashboard Refresh Error:", e);
      new import_obsidian2.Notice("Error refreshing Academic Dashboard. Check console.");
    } finally {
      this.isRefreshing = false;
    }
  }
  // --- Core Refresh Logic ---
  async refresh() {
    var _a;
    if (!((_a = this.containerEl) == null ? void 0 : _a.children[1]))
      return;
    const container = this.containerEl.children[1];
    container.empty();
    const wrapper = container.createDiv({ cls: "academic-dashboard-view" });
    const files = this.getRelevantFiles();
    if (files.length === 0) {
      this.renderEmptyState(wrapper);
      return;
    }
    await Promise.all(files.map((f) => this.updateFileCache(f)));
    const structure = this.structureData(files);
    const l = this.plugin.settings.language;
    const { s1StartDate, s1EndDate, s2StartDate, s2EndDate } = this.plugin.settings;
    await this.renderSemester(wrapper, t(l, "viewSemester1"), structure.s1, s1StartDate, s1EndDate);
    await this.renderSemester(wrapper, t(l, "viewSemester2"), structure.s2, s2StartDate, s2EndDate);
    if (structure.other.length > 0) {
      await this.renderSemester(wrapper, t(l, "viewOthers"), structure.other, "", "", true);
    }
  }
  // --- Data Layer (Optimized) ---
  // Reads file content ONLY if mtime changed.
  async updateFileCache(file) {
    var _a;
    const currentMtime = file.stat.mtime;
    const cached = this.cache.get(file.path);
    if (cached && cached.mtime === currentMtime)
      return;
    try {
      const content = await this.app.vault.cachedRead(file);
      const lines = content.split("\n");
      const metaCache = this.app.metadataCache.getFileCache(file);
      const volProp = this.plugin.settings.volumePropertyName;
      const pomMinutes = this.plugin.settings.pomodoroMinutes;
      const vol = (_a = metaCache == null ? void 0 : metaCache.frontmatter) == null ? void 0 : _a[volProp];
      let totalHours = 0;
      if (vol !== void 0) {
        const val = typeof vol === "string" ? parseFloat(vol) : vol;
        if (!isNaN(val))
          totalHours += val;
      }
      const pTotal = totalHours === 0 ? 0 : Math.ceil(totalHours * 60 / pomMinutes);
      let pDone = 0;
      const taskItems = [];
      const listItems = (metaCache == null ? void 0 : metaCache.listItems) || [];
      for (const item of listItems) {
        if (item.task === void 0)
          continue;
        const lineIndex = item.position.start.line;
        const lineText = lines[lineIndex];
        const match = lineText.match(/\[üçÖ::\s*(\d+)\]/);
        if (match && match[1]) {
          pDone += parseInt(match[1], 10) || 0;
        }
        taskItems.push({
          line: lineIndex,
          text: lineText,
          // Full line for indent calc
          checked: item.task !== " ",
          pomodoro: match && match[1] ? parseInt(match[1], 10) : null
        });
      }
      this.cache.set(file.path, {
        mtime: currentMtime,
        pomodorosDone: pDone,
        pomodorosTotal: pTotal,
        tasks: taskItems
      });
    } catch (e) {
      console.warn(`Failed to process file ${file.path}`, e);
    }
  }
  getRelevantFiles() {
    const { academicYear, propertyName, excludedFolders } = this.plugin.settings;
    if (!academicYear)
      return [];
    const excludes = excludedFolders.split("\n").map((p) => p.trim()).filter((p) => p);
    return this.app.vault.getMarkdownFiles().filter((f) => {
      var _a;
      if (excludes.some((e) => f.path.startsWith(e)))
        return false;
      const fm = (_a = this.app.metadataCache.getFileCache(f)) == null ? void 0 : _a.frontmatter;
      if (!fm || !fm[propertyName])
        return false;
      const years = Array.isArray(fm[propertyName]) ? fm[propertyName] : [fm[propertyName]];
      return years.some((y) => this.cleanText(y) === academicYear);
    });
  }
  structureData(files) {
    const s1 = [];
    const s2 = [];
    const other = [];
    const semProp = this.plugin.settings.semesterPropertyName;
    files.forEach((f) => {
      var _a;
      const fm = (_a = this.app.metadataCache.getFileCache(f)) == null ? void 0 : _a.frontmatter;
      const sem = fm == null ? void 0 : fm[semProp];
      let assigned = false;
      if (sem) {
        const sems = Array.isArray(sem) ? sem : [sem];
        for (const s of sems) {
          const txt = this.cleanText(s);
          if (txt === "S1") {
            s1.push(f);
            assigned = true;
            break;
          }
          if (txt === "S2") {
            s2.push(f);
            assigned = true;
            break;
          }
        }
      }
      if (!assigned)
        other.push(f);
    });
    return { s1, s2, other };
  }
  // --- Render Components (Functional-ish) ---
  renderEmptyState(container) {
    container.createDiv({
      cls: "academic-empty-state",
      text: t(this.plugin.settings.language, "viewNoPages")
    });
  }
  async renderSemester(container, title, files, start, end, forceOpen = false) {
    const details = container.createEl("details", { cls: "academic-dashboard-section" });
    const summary = details.createEl("summary");
    summary.createSpan({ text: title });
    if (end) {
      this.createProgressBar(summary, start, end);
      const dateStr = new Date(end).toLocaleDateString();
      summary.createSpan({ text: ` (${t(this.plugin.settings.language, "viewEnds")} ${dateStr})`, cls: "academic-dashboard-date-label" });
    }
    if (forceOpen || this.isSemesterActive(end))
      details.setAttr("open", "");
    if (files.length === 0) {
      details.createDiv({
        text: t(this.plugin.settings.language, "viewNoCourses"),
        cls: "academic-no-items"
      });
      return;
    }
    const groups = {};
    const ueProp = this.plugin.settings.uePropertyName;
    const otherLabel = t(this.plugin.settings.language, "viewOthers");
    files.forEach((f) => {
      var _a;
      const fm = (_a = this.app.metadataCache.getFileCache(f)) == null ? void 0 : _a.frontmatter;
      let name = otherLabel;
      if (fm && fm[ueProp]) {
        const arr = Array.isArray(fm[ueProp]) ? fm[ueProp] : [fm[ueProp]];
        if (arr.length)
          name = this.cleanText(arr[0]);
      }
      if (!groups[name])
        groups[name] = [];
      groups[name].push(f);
    });
    const sortedKeys = Object.keys(groups).sort((a, b) => {
      if (a === otherLabel)
        return 1;
      if (b === otherLabel)
        return -1;
      return a.localeCompare(b);
    });
    for (const ue of sortedKeys) {
      await this.renderUEGroup(details, ue, groups[ue], ue === otherLabel && sortedKeys.length === 1);
    }
  }
  async renderUEGroup(container, name, files, skipHeader) {
    const wrapper = container.createDiv({ cls: "academic-dashboard-ue-container" });
    let total = 0, done = 0;
    files.forEach((f) => {
      const c = this.cache.get(f.path);
      if (c) {
        total += c.pomodorosTotal;
        done += c.pomodorosDone;
      }
    });
    if (!skipHeader) {
      let label = name;
      if (total > 0 || done > 0)
        label += ` (\u{1F345} ${done}/${total})`;
      wrapper.createDiv({ text: label, cls: "academic-dashboard-ue-header" });
    }
    const ul = wrapper.createEl("ul", { cls: "academic-dashboard-list" });
    for (const f of files) {
      await this.renderFileItem(ul, f);
    }
  }
  async renderFileItem(container, file) {
    var _a;
    const li = container.createEl("li", { cls: "academic-dashboard-item" });
    const header = li.createDiv({ cls: "academic-dashboard-item-header" });
    const info = header.createDiv({ cls: "academic-dashboard-item-info" });
    header.addEventListener("click", (e) => {
      e.preventDefault();
      this.app.workspace.getLeaf(false).openFile(file);
    });
    const cached = this.cache.get(file.path);
    const fm = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
    const titleRow = info.createDiv({ cls: "academic-dashboard-item-title-row" });
    titleRow.createEl("a", { text: file.basename, cls: "academic-dashboard-link" });
    if (fm && fm[this.plugin.settings.supervisionStartPropertyName] && fm[this.plugin.settings.supervisionEndPropertyName]) {
      this.createProgressBar(titleRow, fm[this.plugin.settings.supervisionStartPropertyName], fm[this.plugin.settings.supervisionEndPropertyName], true);
    }
    if (cached && (cached.pomodorosTotal > 0 || cached.pomodorosDone > 0)) {
      titleRow.createSpan({
        text: `\u{1F345} ${cached.pomodorosDone}/${cached.pomodorosTotal}`,
        cls: "academic-dashboard-tag tag-pomodoro"
      });
    }
    const meta = info.createDiv({ cls: "academic-dashboard-item-meta" });
    if (fm == null ? void 0 : fm[this.plugin.settings.evaluationTypePropertyName]) {
      const type = this.cleanText(fm[this.plugin.settings.evaluationTypePropertyName]);
      const badge = meta.createSpan({ text: type, cls: "academic-dashboard-tag tag-eval" });
      this.plugin.settings.evaluationColors.split("\n").forEach((l) => {
        const [k, c] = l.split(":");
        if ((k == null ? void 0 : k.trim()) === type && c) {
          badge.setAttribute("style", `color: ${c.trim()}; border-color: ${c.trim()};`);
        }
      });
    }
    if (fm == null ? void 0 : fm[this.plugin.settings.session1PropertyName])
      this.addDate(meta, fm[this.plugin.settings.session1PropertyName], "S1");
    if (fm == null ? void 0 : fm[this.plugin.settings.session2PropertyName])
      this.addDate(meta, fm[this.plugin.settings.session2PropertyName], "S2");
    if (cached && cached.tasks.length > 0) {
      const allTasksDone = cached.tasks.every((t2) => t2.checked);
      let targetContainer = li;
      if (allTasksDone) {
        li.addClass("is-completed");
        const details = li.createEl("details", { cls: "academic-dashboard-tasks-collapsed" });
        const summary = details.createEl("summary", { cls: "academic-dashboard-tasks-summary" });
        summary.createSpan({ text: t(this.plugin.settings.language, "viewAllTasksDone") });
        targetContainer = details;
      }
      const ul = targetContainer.createEl("ul", { cls: "academic-dashboard-task-list" });
      for (const t2 of cached.tasks) {
        const taskLi = ul.createEl("li", { cls: "academic-dashboard-task-item task-list-item" });
        if (t2.checked)
          taskLi.addClass("is-checked");
        taskLi.setAttribute("data-task", t2.checked ? "x" : " ");
        const indentMatch = t2.text.match(/^(\s*)/);
        if (indentMatch && indentMatch[1]) {
          const w = indentMatch[1];
          const tabs = (w.match(/\t/g) || []).length;
          const sp = (w.match(/ /g) || []).length;
          const px = tabs * 32 + sp * 8;
          if (px > 0)
            taskLi.style.marginLeft = `${px}px`;
        }
        taskLi.createEl("input", {
          type: "checkbox",
          cls: "academic-dashboard-task-checkbox task-list-item-checkbox"
        }).checked = t2.checked;
        const span = taskLi.createEl("span", { cls: "academic-dashboard-task-content" });
        const cleanMD = t2.text.replace(/^\s*[-*+]\d*\.?\s*\[.\]\s*/, "").replace(/\[üçÖ::\s*\d+\]/g, "");
        await import_obsidian2.MarkdownRenderer.render(this.app, cleanMD, span, file.path, this);
        if (t2.pomodoro) {
          taskLi.createSpan({ text: `\u{1F345} ${t2.pomodoro}`, cls: "academic-dashboard-task-pomodoro" });
        }
      }
    }
  }
  // --- Utils ---
  cleanText(val) {
    var _a;
    if (typeof val !== "string")
      return String(val);
    let c = val.replace(/\[\[/g, "").replace(/\]\]/g, "");
    if (c.includes("|"))
      c = ((_a = c.split("|").pop()) == null ? void 0 : _a.trim()) || "";
    return c.trim();
  }
  isSemesterActive(end) {
    return !end || new Date() <= new Date(end);
  }
  addDate(container, dateStr, label) {
    const d = new Date(dateStr);
    if (!isNaN(d.getTime())) {
      container.createSpan({ text: `${label}: ${d.toLocaleDateString()}`, cls: "academic-dashboard-tag tag-date" });
    }
  }
  createProgressBar(container, start, end, mini = false) {
    if (!start || !end)
      return;
    const s = new Date(start).getTime();
    const e = new Date(end).getTime();
    const now = Date.now();
    if (isNaN(s) || isNaN(e))
      return;
    const total = e - s, elapsed = now - s;
    const pct = Math.max(0, Math.min(100, elapsed / total * 100));
    const l = this.plugin.settings.language;
    let text = "";
    if (now < s) {
      const d = Math.ceil((s - now) / 864e5);
      text = mini ? `${t(l, "progStartInMini")}${d}${t(l, "progDays")}` : `${t(l, "progStartIn")} ${d}${t(l, "progDays")}`;
    } else if (now >= e)
      text = t(l, "progDone");
    else {
      const w = Math.ceil((e - now) / 6048e5);
      text = mini ? `${w}${t(l, "progWeeks")}` : `${w} ${t(l, "progWeeksLeft")}`;
    }
    const wrap = container.createSpan({ cls: `academic-dashboard-progress-container${mini ? " mini" : ""}` });
    const bar = wrap.createDiv({ cls: `academic-dashboard-progress-bar${mini ? " mini" : ""}` });
    bar.createDiv({ cls: "academic-dashboard-progress-fill", attr: { style: `width: ${pct}%` } });
    wrap.createSpan({ text, cls: "academic-dashboard-progress-text" });
  }
  async onClose() {
  }
};

// src/main.ts
var VIEW_TYPE_ACADEMIC_DASHBOARD = "academic-dashboard-view";
var AcademicDashboardPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE_ACADEMIC_DASHBOARD,
      (leaf) => new AcademicDashboardView(leaf, this)
    );
    this.addRibbonIcon("graduation-cap", "Academic Dashboard", () => {
      this.activateView("center");
    });
    this.addSettingTab(new AcademicDashboardSettingTab(this.app, this));
  }
  async onunload() {
  }
  async activateView(direction = "sidebar") {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_ACADEMIC_DASHBOARD);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      if (direction === "sidebar") {
        leaf = workspace.getRightLeaf(false);
      } else {
        leaf = workspace.getLeaf(true);
      }
      if (leaf) {
        await leaf.setViewState({ type: VIEW_TYPE_ACADEMIC_DASHBOARD, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_ACADEMIC_DASHBOARD);
    leaves.forEach((leaf) => {
      if (leaf.view instanceof AcademicDashboardView) {
        leaf.view.refresh();
      }
    });
  }
};
